# Обоснование Модели Данных LMS

Документ фиксирует, почему в `001_schema.sql` выбраны именно такие типы данных, ограничения и связи.

## 1. Общие принципы

- Нормализация:
  - сущности разделены по предметной области (`users`, `courses`, `lessons`, `assignments` и т.д.)
  - дублирование сведено к минимуму
- Целостность:
  - внешние ключи (`FOREIGN KEY`) обеспечивают корректные связи
  - `UNIQUE` и `CHECK` не дают записать неконсистентные данные
- Аудит и мягкое удаление:
  - `created_at`, `updated_at`, `deleted_at` позволяют хранить историю и не терять данные при бизнес-удалении
- Масштабируемость:
  - UUID в качестве ключей удобен для распределенных систем и интеграций

## 2. Выбор ключевых типов данных

- `UUID`:
  - используется как PK во всех бизнес-таблицах (`users`, `courses`, `enrollments`, `lessons`, `assignments`, `submissions`, `grades`, `progress`)
  - причина: глобальная уникальность и отсутствие коллизий при возможной микросервисной эволюции
- `SMALLSERIAL` в `roles.id`:
  - справочник ролей маленький и статичный
  - компактный тип быстрее и экономнее по памяти, чем UUID
- `TIMESTAMPTZ`:
  - для всех временных полей (`created_at`, `updated_at`, `due_date`, `submitted_at`, `graded_at`)
  - причина: корректная работа с часовыми поясами и предсказуемое поведение в API
- `TEXT`:
  - для потенциально длинного контента (`description`, `content`, `feedback`, `password_hash`)
  - причина: отсутствие искусственных ограничений длины там, где они не нужны
- `VARCHAR(n)`:
  - для полей с разумной верхней границей (`email`, `title`, `full_name`, `role.name`)
  - причина: явный контракт структуры данных и более четкая валидация на уровне БД
- `BOOLEAN`:
  - для флагов состояния (`is_active`, `is_published`, `completed`)
- `INT`:
  - для числовых показателей (`max_score`, `score`, `position`)

## 3. Обоснование таблиц и связей

### `roles`
- Назначение: справочник ролей (`student`, `teacher`, `admin`)
- Почему отдельно:
  - легче расширять ролевую модель без миграции `users`
  - проще строить RBAC в backend

### `users`
- Связь: `users.role_id -> roles.id`
- Ключевые ограничения:
  - `email UNIQUE NOT NULL`
  - `users_email_format_chk` через regex
- Почему одна таблица пользователей:
  - индустриальный стандарт вместо отдельных `students`/`teachers`
  - единая авторизация и аудит

### `courses`
- Связь: `courses.teacher_id -> users.id`
- Ограничения:
  - `courses_title_non_empty`
- Почему так:
  - курс всегда имеет автора-преподавателя
  - `is_published` отделяет черновики от открытых курсов

### `enrollments`
- Связи:
  - `enrollments.user_id -> users.id`
  - `enrollments.course_id -> courses.id`
- Ограничение:
  - `UNIQUE (user_id, course_id)`
- Почему:
  - это классическая many-to-many между студентами и курсами
  - уникальность предотвращает повторную запись

### `lessons`
- Связь: `lessons.course_id -> courses.id`
- Ограничения:
  - `position > 0`
  - `UNIQUE (course_id, position)`
- Почему:
  - порядок уроков фиксирован внутри курса
  - одна позиция не может повторяться в одном курсе

### `assignments`
- Связь: `assignments.lesson_id -> lessons.id`
- Ограничения:
  - `max_score > 0`
- Почему:
  - задание принадлежит уроку и наследует контекст курса через `lessons`

### `submissions`
- Связи:
  - `submissions.assignment_id -> assignments.id`
  - `submissions.student_id -> users.id`
- Ограничение:
  - `UNIQUE (assignment_id, student_id)`
- Почему:
  - одна актуальная отправка на задание для студента (в MVP модель переотправки реализована как update)

### `grades`
- Связи:
  - `grades.submission_id -> submissions.id`
  - `grades.graded_by -> users.id`
- Ограничения:
  - `submission_id UNIQUE` (одна итоговая оценка на отправку)
  - `score >= 0`
- Почему:
  - отделение оценки от отправки упрощает расширение (история проверок, ревью, ассистенты)

### `progress`
- Связи:
  - `progress.user_id -> users.id`
  - `progress.lesson_id -> lessons.id`
- Ограничение:
  - `UNIQUE (user_id, lesson_id)`
- Почему:
  - хранит факт прохождения поурочно
  - основа для аналитики “прогресса обучения”

## 4. Индексы

Индексы поставлены на колонках, участвующих в:
- фильтрации (`role_id`, `teacher_id`)
- соединениях (`user_id`, `course_id`, `lesson_id`, `assignment_id`, `submission_id`)
- частых запросах “мои данные”

Примеры:
- `idx_courses_teacher_id` ускоряет выборку курсов преподавателя
- `idx_enrollments_user_id` ускоряет “мои курсы” студента
- `idx_submissions_assignment_id` ускоряет просмотр решений по заданию

## 5. Триггеры и audit-логика

- Функция `update_updated_at_column()`:
  - на `BEFORE UPDATE` обновляет `updated_at = NOW()`
- Почему:
  - синхронизирует audit-поля независимо от backend-кода
  - снижает риск “забыть обновить время” в приложении

## 6. Почему soft delete (`deleted_at`)

- Данные не удаляются физически сразу
- Плюсы:
  - можно восстановить запись
  - безопаснее для связанной аналитики и отчетности
  - проще отлаживать спорные случаи в учебных сценариях

## 7. Альтернативы и почему не выбраны в MVP

- Отдельные таблицы `students/teachers`:
  - сложнее поддержка авторизации и RBAC
- Жесткие `ENUM` для ролей:
  - lookup-таблица `roles` более гибкая для расширения
- Физическое удаление:
  - выше риск потери связанной истории

## 8. Итог

Модель ориентирована на:
- понятность для курсового проекта
- корректность данных на уровне БД
- практическую готовность к backend API и дальнейшему росту функциональности
